# iOSArina
ДЗ-v2
1. Два архитектурных паттерны и принципы SOLID при их имплементации Ответы: 
    1. Принцип единственной ответственности (Single Responsibility Principle): 
        1. MVP - M -  модель, ответственна за данные, V - отображение данных и перенаправление событий в Presenter, Presenter - содержит в себе всю логику представления данных о предметной области; при необходимости получает данные из хранилища и преобразует для отображения во View.
        2. VIPER - образец архитектуры в которой реализован данный принцип.  V - отображение данных,  Interactor содержит бизнес-логику, связанную с данными (Entities), Presenter содержит бизнес-логику, связанную c UI (но UIKit-независимую), вызывает методы в Interactor. Entities — простые объекты данных, не являются слоем доступа к данным, потому что это ответственность слоя Interactor. Router несет ответственность за переходы между VIPER-модулями
    2. Принцип открытости/закрытости (Open-closed Principle): 
        1.  если MVP реализовывать вместе с протоколами - то есть у View будет свойство типа протокол Presenter(а не на объект конкретного(Custom) Presenter), то будет реализован этот принцип.
        2. В VIPER модули жёстко не завязаны друг на друге, взаимодействие больше напоминает конструктор лего. То есть можно сделать базовый Router у которого будет основной метод - вернутся назад, и использовать его для все View модулей, и сделать наследников от него в которых реализовывать уже другие вызовы - открыть определённый экран и тд. И тогда базовый Router не придётся изменять, а через его наследников реализовать другие функции.
    3. Принцип подстановки Барбары Лисков (Liskov Substitution Principle) 
        1. например функционал UIViewController можно расширить за счёт UITextFieldDelegate - для работы с текстовыми полями. Например если создать базовый UIViewController который будет взаимодействовать с Presenter на основе определённых методов, а дальше уже разные подклассы базового вью контролера можно будет расширять за счёт UITextFieldDelegate, UItableViewDelegate и тд.
        2. Практически пункт 2-2 подтверждает и этот принцип. Router в VIPER оперирует VC вне зависимости от того какой он там внутри.
    4. Принцип разделения интерфейса (Interface Segregation Principle)
        1. по своей сути View и Presenter в MVP реализуют это, так как в отличии от MVC в MVP ViewController разгрузили за счёт вынесения методов связанных с настройкой отображения в Presenter
        2. Существует вариант VIPER c input/output интерфейсами. Это два разных протокола у Presenter для взаимодействия с Interactor и с VIEW.
    5. Принцип инверсии зависимостей (Dependency Inversion Principle)
        1. MVP взаимозависимость между модулями V и P можно сделать на основе протокола или базового класса,  и в итоге к Presenter-у можно будет подключать разные View.
        2. Аналогично и в VIPER  - все слои не знают про реализацию и них есть только ссылки на объекты определённых протоколов.
2. Два GOF-паттерна и принципы SOLID при их имплементации
    1. Фабрика - во первых у неё единственная ответственность(создавать объекты классов)(S), в принципе реализует принцип открытости/закрытости(O)
    2. Стратегия - Изолирует код и данные алгоритмов от остальных классов(S), реализует принцип открытости/закрытости(O)
3. ООП Битва магов. Маг знает какое-то количество различных заклинаний. Каждое заклинание имеет случайный урон из диапазона. Диапазон зависит от уровня магов. Термины ООП для задачи. Какие GoF паттерны можно применить. Архитектурный паттерн для визуализации и почему.
    1. Класс Маг. Его свойства: уровень, жизненная энергия, массив заклинаний. 
    2. Класс Заклинание. Его свойство - урон. 
    3. Класс Битва. Свойства: Маг 1 и Маг. 2, или массив магов.
    4. Визуализация битвы: MVP. Так как небольшой проект, немного экранов и нет связи с сервером. Поэтому данные можно будет хранить в UserDefaults или локально в CoreData. Загружать их с помощью класса Service в Presenter. А дальше во ViewController отображать список магов и view с анимацией битвы.
    5. Применяем паттерн Фабрика для генерации заклинаний в зависимости от уровня для Магов.
    6. Сам класс Битва реализует паттерн Стратегия:
        1. Применить заклинание
        2. Посчитать урон
        3. Если жизней больше 0 то продолжить ход другим магом
